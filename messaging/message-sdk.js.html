<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: message-sdk.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: message-sdk.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import _ from 'lodash'
import gaManager from '../libs/ga-manager'
import MessagingClient from '../libs/messaging-client'

/**
 * MessageManager is a browser-side SDK, please
 * use global function createMessageManager to get instance
 */
class MessageManager extends MessagingClient {
  /**
   * Please use global function createMessageManager to instead of new a MessageManager instance
   * @constructor
   */
  constructor(sdkConfig) {
    super(sdkConfig.accountId, sdkConfig.memberToken)
    gaManager.init(sdkConfig.accountId)
  }

  /**
   * To call Init function is required, after getting MessageManager instance
   * from function createMessageManager
   * @return {Promise} a promise
   */
  init() {
    return super.init()
  }

  /**
   * Connect to a specific chat room, by chatroomName, which is defined by developers
   * @param  {string} chatroomName chat room name
   * @param  {object} options
   * @param  {object} options.events
   * @param  {function} options.events.user_meta:(self) triggers when user meta are arrived
   * @param  {function} options.events.user_update:(users) triggers when users are updated
   * @param  {function} options.events.user_add:(users) triggers when new users are arrived
   * @param  {function} options.events.user_remove:(users) triggers when users left the chat room
   * @param  {function} options.events.chat_meta:(meta) triggers when chat room meta are arrived
   * @param  {function} options.events.chat_write_mode:(chatWriteMode) triggers when chat_write_mode
   *                    is changed
   * @param  {function} options.events.message_input_interval:(inputInterval) triggers when
   *                    message_input_interval is changed,
   *                    usually happen when message number is too large
   * @param  {function} options.events.user_count:(userCount) triggers when server automatically
   *                    broadcasting user count
   * @param  {function} options.events.messages:(msg) triggers when new messages are arrived
   * @param  {function} options.events.message_flush triggers when admin clean up all the messages
   * @param  {function} options.events.message_remove:(mid) triggers when single message is removed
   * @param  {function} options.events.aggregated_data_add:(msg) triggers when new aggregated
   *                    messages are arrived
   * @param  {function} options.events.raw_data_add:(msg) triggers when new raw messages are arrived
   * @param  {function} options.events.connection_status:(status) triggers chat room status
   *                    is changed
   * @param  {bool} options.isPersonalChat whether the target chat room is a personal chat room
   * @return  {Promise} a promise
   */
  connect(chatroomName, options = {}) {
    return super.connect(chatroomName, options)
  }

  /**
   * Disconnect from a specific chat room
   * @param  {string} chatroomName chat room name
   * @return  {Promise} a promise
   */
  disconnect(chatroomName) {
    return super.disconnect(chatroomName)
  }

  /**
   * Send message to a specific chat room
   * @param  {string} chatroomName chat room name
   * @param  {string} message a simple string, e.g. "abc", should within 300 characters
   * @return  {Promise} a promise
   */
  sendMessage(chatroomName, message) {
    return super.sendMessage(chatroomName, message)
  }

  /**
   * Send a string to a specific chat room which is aggregated in aggregated_data_add
   * @param  {string} chatroomName chat room name
   * @param  {string} message a simple string, e.g. "like", "cry", should within 100 characters
   * @return  {Promise} a promise
   */
  sendAggregatedDataTypeMessage(chatroomName, message) {
    return super.sendAggregatedDataTypeMessage(chatroomName, message)
  }

  /**
   * Send the raw data to a specific chat room, this type of message is not aggregated
   * @param  {string} chatroomName chat room name
   * @param  {string} message a json or array type of message, e.g. "{ id: 1 } or [{ id: 1 }]",
   *                  should within 2048 characters
   * @return  {Promise} a promise
   */
  sendRawData(chatroomName, message) {
    return super.sendRawData(chatroomName, message)
  }

  /**
   * Update the current user's nickname
   * @param  {string} chatroomName chat room name
   * @param  {string} nickname a nickname to update
   * @return  {Promise} a promise
   */
  updateNickName(chatroomName, nickname) {
    return super.updateNickName(chatroomName, nickname)
  }

  /**
   * Update the role by user id for a specific user
   * @param  {string} chatroomName chat room name
   * @param  {string} userId the user id of a specific user
   * @param  {string} role MODERATOR|NORMAL
   * @return  {Promise} a promise
   */
  updateUserRoleByUserId(chatroomName, userId, role) {
    return super.updateUserRoleByUserId(chatroomName, userId, role)
  }

  /**
   * Update the role by label for a specific user
   * @param  {string} chatroomName chat room name
   * @param  {string} label the label of a specific user
   * @param  {string} role MODERATOR|NORMAL
   * @return  {Promise} a promise
   */
  updateUserRoleByLabel(chatroomName, label, role) {
    return super.updateUserRoleByLabel(chatroomName, label, role)
  }

  /**
   * Update the role by member id for a specific user
   * @param  {string} chatroomName chat room name
   * @param  {string} memberId the member id of a specific user
   * @param  {string} role MODERATOR|NORMAL
   * @return  {Promise} a promise
   */
  updateUserRoleByMemberId(chatroomName, memberId, role) {
    return super.updateUserRoleByMemberId(chatroomName, memberId, role)
  }

  /**
   * Show all the connected chat room
   * @return {array} names of all connected chat rooms
   */
  getConnectedRooms() {
    return super.getConnectedRooms()
  }

  /**
   * Show related meta for a specific chat room
   * @param  {string} chatroomName chat room name
   * @return {object} meta object of chat room
   */
  getChatroomMeta(chatroomName) {
    return super.getChatroomMeta(chatroomName)
  }

  /**
   * Return all a specific type of users in a specific chat room
   * @param  {string} chatroomName chat room name
   * @param  {string} userType onlineUser|blocked|supervisor,
   *                           onlineUser=[GLOBAL_MANAGER, LOCAL_MANAGER,
   *                           MASTER, MODERATOR, NORMAL] ;
   *                           blocked=[BLOCKED] ;
   *                           supervisor=[GLOBAL_MANAGER, LOCAL_MANAGER, MODERATOR]
   * @return {object} users - array of users
   */
  getUsers(chatroomName, userType) {
    return super.getUsers(chatroomName, userType)
  }

  /**
   * Return all messages in a specific chat room
   * @param  {string} chatroomName chat room name
   * @param  {object} options
   * @param  {number} options.page undefined or null imply no shift, default is 1
   * @param  {number} options.perPage default is 10 and MAX is 100
   * @param  {number} options.oldestDate unix time in millisecond,
   *                  ex: 1406183498018, undefined or null imply no constraint
   * @param  {number} options.latestDate unix time in millisecond,
   *                  ex: 1406183498018, undefined or null imply no constraint
   * @param  {string} options.order asc|desc, order by created_date with asc or desc ordering,
   *                  default is desc
   * @return {object} messages - array of messages
   */
  getMessages(chatroomName, options) {
    return super.getMessages(chatroomName, options)
  }

  /**
   * Return aggregate data in a specific chat room
   * @param  {string} chatroomName chat room name
   * @param  {object} options
   * @param  {number} options.page undefined or null imply no shift, default is 1
   * @param  {number} options.perPage default is 10 and MAX is 100
   * @param  {number} options.oldestDate unix time in millisecond,
   *                  ex: 1406183498018, undefined or null imply no constraint
   * @param  {number} options.latestDate unix time in millisecond,
   *                  ex: 1406183498018, undefined or null imply no constraint
   * @param  {string} options.order asc|desc, order by created_date with asc or desc ordering,
   *                  default is desc
   * @return {object} messages - array of messages
   */
  getAggregatedData(chatroomName, options) {
    return super.getAggregatedData(chatroomName, options)
  }

  /**
   * Return raw data in a specific chat room
   * @param  {string} chatroomName chat room name
   * @param  {object} options
   * @param  {number} options.page undefined or null imply no shift, default is 1
   * @param  {number} options.perPage default is 10 and MAX is 100
   * @param  {number} options.oldestDate unix time in millisecond,
   *                  ex: 1406183498018, undefined or null imply no constraint
   * @param  {number} options.latestDate unix time in millisecond,
   *                  ex: 1406183498018, undefined or null imply no constraint
   * @param  {string} options.order asc|desc, order by created_date with asc or desc ordering,
   *                  default is desc
   * @return {object} messages - array of messages
   */
  getRawData(chatroomName, options) {
    return super.getRawData(chatroomName, options)
  }

  /**
   * Remove a message by message id from a specific chat room
   * @param  {string} chatroomName chat room name
   * @param  {string} messageId message id to remove
   * @return  {Promise} a promise
   */
  removeMessage(chatroomName, messageId) {
    return super.removeMessage(chatroomName, messageId)
  }

  /**
   * Flush all messages from a specific chat room
   * @param  {string} chatroomName chat room name
   * @return  {Promise} a promise
   */
  flushMessage(chatroomName) {
    return super.flushMessage(chatroomName)
  }

  /**
   * Change a chat write mode from a specific chat room
   * @param  {string} chatroomName chat room name
   * @param  {string} mode ALL|LOGIN|ANCHOR
   * @return  {Promise} a promise
   */
  changeChatWriteMode(chatroomName, mode) {
    return super.changeChatWriteMode(chatroomName, mode)
  }

  /**
   * Return the current user related meta in a specific chat room
   * @param  {string} chatroomName chat room name
   * @return {object} user meta object
   */
  getCurrentUserInChatroom(chatroomName) {
    return super.getCurrentUserInChatroom(chatroomName)
  }

  /**
   * Block the user/users from a specific chat room
   * @param  {string} chatroomName chat room name
   * @param  {string|array} userLabels a single label or an array of labels
   * @return  {Promise} a promise
   */
  blockUser(chatroomName, userLabels) {
    return super.blockUser(chatroomName, userLabels)
  }

  /**
   * Get status from a specific chat room
   * @param  {string} chatroomName chat room name
   * @return  {string} DISCONNECTING|CONNECTING|CONNECTED|IDLE|NOT_USE
   */
  getRoomStatus(chatroomName) {
    return super.getRoomStatus(chatroomName)
  }

  /**
   * Get all aggregated data from a specific chat room
   * @param  {string} chatroomName chat room name
   * @return  {array} an array of aggregated data key and n
   */
  getTotalAggregatedData(chatroomName) {
    return super.getTotalAggregatedData(chatroomName)
  }
}

/**
 * Create message manager sdk
 * Synchronously initiate a messaging manager with a cms account id and an user access token
 * Note you should use promise style to handle the callback
 * @param {object} sdkConfig
 * @param {string} sdkConfig.accountId required, a cms account id
 * @param {string} sdkConfig.memberJWT optional, a jwt token to identify an user
 * @return {object} a MessageManager instance
 */
export function createMessageManager(sdkConfig) {
  _.forEach(['accountId'], (v) => {
    if (_.isUndefined(sdkConfig[v])) {
      throw new Error(`config ${v} is required`)
    }
  })
  return new MessageManager(sdkConfig)
}

if (typeof window !== 'undefined') {
  window.StraaS = { createMessageManager }
}

if (typeof window !== 'undefined' &amp;&amp; _.isFunction(window.onStraaSMessageManagerSdkReady)) {
  window.onStraaSMessageManagerSdkReady(createMessageManager)
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MessageManager.html">MessageManager</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createMessageManager">createMessageManager</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Feb 21 2017 13:35:18 GMT+0800 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
